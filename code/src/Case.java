/**
* Holds part of p3p policy, a bit with data type (primary value), recipient, retention, purpose, and a distance function
*
*/


/**
 * Case class
 * containing the unique key data and arrays of Recipient Purpose and Retention
 * with corresponding get and set methods
 * @version 160911.1
 * @author Dimitry Kongevold (dimitryk)
 */

class Case{
	private String data;
	private Recipient[] recip;
	private Purpose[] purp;
	private Retention[] ret;
	

	/**
	 * Paragraph laying out constructor details, etc. 
	 * Constructor can be auto-generated by Source->Generate Constructor...
	 * 
	 * @author dimitryk
	 * 
	 * @param String name saves the data key
	 * 
	 */

	Case(String name){
	
		data = name;
	}
	/**
	 * adds a single Recipient to an array.
	 * if array is empty the array of length 1 is created 
	 * and for loop never activated changing this recip array to new array
	 * Contaning Newresipien at resip[0]
	 * @author dimitryk
	 * @param Newrecip input Recipient
	 */
	
	
	public void addRecip(Recipient newrecip){
		Recipient newArray[]= new Recipient[recip.length+1];
		for(int i=0;i<recip.length;i++){
			newArray[i]=recip[i];
		}
		newArray[recip.length]=newrecip;
		this.recip=newArray;
	}
	
	/**
	 * adds a array of Recipients to an array resip.
	 * if array is empty the array of Newresip.length is created 
	 * and 1st for loop never activated changing this recip array to new array
	 * Contaning Newresip[]
	 * @author dimitryk
	 * @param Newrecip[] input Recipient
	 */
	
	public void addResip(Recipient Newrecip[]){
		Recipient newArray[]= new Recipient[recip.length+Newrecip.length];
		for(int i=0;i<recip.length;i++){
			newArray[i]=recip[i];
		}
		for(int d=0;d<Newrecip.length;d++){
			newArray[d+recip.length]=Newrecip[d+recip.length];
		}
		this.recip=newArray;
	}
	
	/**
	 * returns this.recip
	 * @author dimitryk
	 * @return this.recip
	 */
	
	public Recipient[] getRecip(){
		return recip;
	}
	
	/**
	 * returns this.recip[i]
	 * @author dimitryk
	 * @param i input int
	 * @return this.recip[i]
	 */
	
	public Recipient getRecip(int i){
		if(i>0&&i<recip.length)return recip[i];
		else return null;
			//throw new OutOfBoundsException();    //this we need to think about
	}
	
	/**
	 * adds a single Purpose to an array.
	 * if array is empty the array of length 1 is created 
	 * and for loop never activated changing this purp array to new array
	 * Contaning Newresipien at purp[0]
	 * @author dimitryk
	 * @param Newpurp input Purpose
	 */
	
	public void addPurp(Purpose newpurp){
		Purpose newArray[]= new Purpose[purp.length+1];
		for(int i=0;i<purp.length;i++){
			newArray[i]=purp[i];
		}
		newArray[purp.length]=newpurp;
		this.purp=newArray;
	}
	/**
	 * adds array of Purposes to an array this.purp.
	 * @author dimitryk
	 * @param Newpurp[] input Purpose
	 */
	
	public void addPurp(Purpose Newpurp[]){
		Purpose newArray[]= new Purpose[purp.length+Newpurp.length];
		for(int i=0;i<purp.length;i++){
			newArray[i]=purp[i];
		}
		for(int d=0;d<Newpurp.length;d++){
			newArray[d+purp.length]=Newpurp[d+purp.length];
		}
		this.purp=newArray;
	}
	/**
	 * returns this.purp
	 * @author dimitryk
	 * @return this.purp
	 */
	public Purpose[] getPurp(){
		return purp;
	}
	/**
	 * returns this.purp[i]
	 * @author dimitryk
	 * @param i input int
	 * @return this.purp[i]
	 */
	public Purpose getPurp(int i){
		if(i>0&&i<purp.length)return purp[i];
		else return null;
			//throw new OutOfBoundsException();    //this we need to think about
	}
	/**
	 * adds a single Retention to an array.
	 * @author dimitryk
	 * @param Newpurp input Purpose
	 */
	public void addRet(Retention newret){
		Retention newArray[]= new Retention[ret.length+1];
		for(int i=0;i<ret.length;i++){
			newArray[i]=ret[i];
		}
		newArray[ret.length]=newret;
		this.ret=newArray;
	}
	/**
	 * adds a array of Retention to an array ret.
	 * @author dimitryk
	 * @param Newpurp input Purpose
	 */
	public void addret(Retention Newret[]){
		Retention newArray[]= new Retention[ret.length+Newret.length];
		for(int i=0;i<ret.length;i++){
			newArray[i]=ret[i];
		}
		for(int d=0;d<Newret.length;d++){
			newArray[d+ret.length]=Newret[d+ret.length];
		}
		this.ret=newArray;
	}
	/**
	 * returns this.ret
	 * @author dimitryk
	 * @return this.ret
	 */
	public Retention[] getRet(){
		return ret;
	}
	/**
	 * returns this.ret[i]
	 * @author dimitryk
	 * @param i input int
	 * @return this.ret[i]
	 */
	public Retention getret(int i){
		if(i>0&&i<ret.length)return ret[i];
		else return null;
			//throw new OutOfBoundsException();    //this we need to think about
	}
}